== Задание 1

Загрузите модуль pyplot библиотеки matplotlib с псевдонимом plt, а также
библиотеку numpy с псевдонимом np. Примените магическую функцию
%matplotlib inline для отображения графиков в Jupyter Notebook и
настройки конфигурации ноутбука со значением `svg' для более четкого
отображения графиков. Создайте список под названием x с числами 1, 2, 3,
4, 5, 6, 7 и список y с числами 3.5, 3.8, 4.2, 4.5, 5, 5.5, 7. С помощью
функции plot постройте график, соединяющий линиями точки с
горизонтальными координатами из списка x и вертикальными - из списка y.
Затем в следующей ячейке постройте диаграмму рассеяния (другие названия
- диаграмма разброса, scatter plot).


+*In[58]:*+
[source, ipython3]
----
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
%matplotlib inline
%config InlineBackend.figure_format = 'svg'
----


+*In[59]:*+
[source, ipython3]
----
x = [1, 2, 3, 4, 5, 6, 7]
x
----


+*Out[59]:*+
----[1, 2, 3, 4, 5, 6, 7]----


+*In[60]:*+
[source, ipython3]
----
y = [3.5, 3.8, 4.2, 4.5, 5, 5.5, 7]
y
----


+*Out[60]:*+
----[3.5, 3.8, 4.2, 4.5, 5, 5.5, 7]----


+*In[61]:*+
[source, ipython3]
----
plt.plot(x, y)

plt.show()
----


+*Out[61]:*+
----
![svg](output_4_0.svg)
----


+*In[62]:*+
[source, ipython3]
----
plt.scatter(x, y)

plt.show()
----


+*Out[62]:*+
----
![svg](output_5_0.svg)
----

== Задание 2

С помощью функции linspace из библиотеки Numpy создайте массив t из 51
числа от 0 до 10 включительно. Создайте массив Numpy под названием f,
содержащий косинусы элементов массива t. Постройте линейную диаграмму,
используя массив t для координат по горизонтали,а массив f - для
координат по вертикали. Линия графика должна быть зеленого цвета.
Выведите название диаграммы - `График f(t)'. Также добавьте названия для
горизонтальной оси - `Значения t' и для вертикальной - `Значения f'.
Ограничьте график по оси x значениями 0.5 и 9.5, а по оси y - значениями
-2.5 и 2.5.


+*In[63]:*+
[source, ipython3]
----
t = np.linspace(0, 10, 51)
t
----


+*Out[63]:*+
----array([ 0. ,  0.2,  0.4,  0.6,  0.8,  1. ,  1.2,  1.4,  1.6,  1.8,  2. ,
        2.2,  2.4,  2.6,  2.8,  3. ,  3.2,  3.4,  3.6,  3.8,  4. ,  4.2,
        4.4,  4.6,  4.8,  5. ,  5.2,  5.4,  5.6,  5.8,  6. ,  6.2,  6.4,
        6.6,  6.8,  7. ,  7.2,  7.4,  7.6,  7.8,  8. ,  8.2,  8.4,  8.6,
        8.8,  9. ,  9.2,  9.4,  9.6,  9.8, 10. ])----


+*In[64]:*+
[source, ipython3]
----
f = np.cos(t)
f
----


+*Out[64]:*+
----array([ 1.        ,  0.98006658,  0.92106099,  0.82533561,  0.69670671,
        0.54030231,  0.36235775,  0.16996714, -0.02919952, -0.22720209,
       -0.41614684, -0.58850112, -0.73739372, -0.85688875, -0.94222234,
       -0.9899925 , -0.99829478, -0.96679819, -0.89675842, -0.79096771,
       -0.65364362, -0.49026082, -0.30733287, -0.11215253,  0.08749898,
        0.28366219,  0.46851667,  0.63469288,  0.77556588,  0.88551952,
        0.96017029,  0.9965421 ,  0.99318492,  0.95023259,  0.86939749,
        0.75390225,  0.60835131,  0.43854733,  0.25125984,  0.05395542,
       -0.14550003, -0.33915486, -0.51928865, -0.67872005, -0.81109301,
       -0.91113026, -0.97484362, -0.99969304, -0.98468786, -0.93042627,
       -0.83907153])----


+*In[65]:*+
[source, ipython3]
----
plt.plot(t, f, color="green")

plt.title("График f(t)")
plt.xlabel("Значения t")
plt.ylabel("Значения f")

plt.axis([0.5, 9.5, -2.5, 2.5])

plt.show()
----


+*Out[65]:*+
----
![svg](output_9_0.svg)
----

== *Задание 3

С помощью функции linspace библиотеки Numpy создайте массив x из 51
числа от -3 до 3 включительно. Создайте массивы y1, y2, y3, y4 по
следующим формулам: y1 = x**2 y2 = 2 * x + 0.5 y3 = -3 * x - 1.5 y4 =
sin(x) Используя функцию subplots модуля matplotlib.pyplot, создайте
объект matplotlib.figure.Figure с названием fig и массив объектов Axes
под названием ax,причем так, чтобы у вас было 4 отдельных графика в
сетке, состоящей из двух строк и двух столбцов. В каждом графике массив
x используется для координат по горизонтали.В левом верхнем графике для
координат по вертикали используйте y1,в правом верхнем - y2, в левом
нижнем - y3, в правом нижнем - y4.Дайте название графикам: `График y1',
`График y2' и т.д. Для графика в левом верхнем углу установите границы
по оси x от -5 до 5. Установите размеры фигуры 8 дюймов по горизонтали и
6 дюймов по вертикали. Вертикальные и горизонтальные зазоры между
графиками должны составлять 0.3.


+*In[66]:*+
[source, ipython3]
----
x = np.linspace(-3, 3, 51)
x
----


+*Out[66]:*+
----array([-3.  , -2.88, -2.76, -2.64, -2.52, -2.4 , -2.28, -2.16, -2.04,
       -1.92, -1.8 , -1.68, -1.56, -1.44, -1.32, -1.2 , -1.08, -0.96,
       -0.84, -0.72, -0.6 , -0.48, -0.36, -0.24, -0.12,  0.  ,  0.12,
        0.24,  0.36,  0.48,  0.6 ,  0.72,  0.84,  0.96,  1.08,  1.2 ,
        1.32,  1.44,  1.56,  1.68,  1.8 ,  1.92,  2.04,  2.16,  2.28,
        2.4 ,  2.52,  2.64,  2.76,  2.88,  3.  ])----


+*In[67]:*+
[source, ipython3]
----
y1 = x**2 
y2 = 2 * x + 0.5
y3 = -3 * x - 1.5
y4 = np.sin(x)
----


+*In[91]:*+
[source, ipython3]
----
fig, ax = plt.subplots(nrows=2, ncols=2, figsize=(8, 6))
plt.subplots_adjust(wspace=0.3, hspace=0.3)
ax1, ax2, ax3, ax4 = ax.flatten()

ax1.set_xlabel("X")
ax1.set_ylabel("y1")
ax1.set_title("График y1")
ax1.set_xlim(-5, 5)
ax1.plot(x, y1)

ax2.set_xlabel("X")
ax2.set_ylabel("y2")
ax2.set_title("График y2")
ax2.plot(x, y2)

ax3.set_xlabel("X")
ax3.set_ylabel("y3")
ax3.set_title("График y3")
ax3.plot(x, y3)

ax4.set_xlabel("X")
ax4.set_ylabel("y4")
ax4.set_title("График y4")
ax4.plot(x, y4)
----


+*Out[91]:*+
----[<matplotlib.lines.Line2D at 0x1947483dd00>]
![svg](output_13_1.svg)
----

== *Задание 4

В этом задании мы будем работать с датасетом, в котором приведены данные
по мошенничеству с кредитными данными: Credit Card Fraud Detection
(информация об авторах: Andrea Dal Pozzolo, Olivier Caelen, Reid A.
Johnson and Gianluca Bontempi. Calibrating Probability with
Undersampling for Unbalanced Classification. In Symposium on
Computational Intelligence and Data Mining (CIDM), IEEE, 2015).
Ознакомьтесь с описанием и скачайте датасет creditcard.csv с сайта
Kaggle.com по ссылке: Credit Card Fraud Detection Данный датасет
является примером несбалансированных данных, так как мошеннические
операции с картами встречаются реже обычных. Импортруйте библиотеку
Pandas, а также используйте для графиков стиль ``fivethirtyeight''.
Посчитайте с помощью метода value_counts количество наблюдений для
каждого значения целевой переменной Class и примените к полученным
данным метод plot, чтобы построить столбчатую диаграмму. Затем постройте
такую же диаграмму, используя логарифмический масштаб. На следующем
графике постройте две гистограммы по значениям признака V1 - одну для
мошеннических транзакций (Class равен 1) и другую - для обычных (Class
равен 0). Подберите значение аргумента density так, чтобы по вертикали
графика было расположено не число наблюдений, а плотность распределения.
Число бинов должно равняться 20 для обеих гистограмм, а коэффициент
alpha сделайте равным 0.5, чтобы гистограммы были полупрозрачными и не
загораживали друг друга. Создайте легенду с двумя значениями: ``Class
0'' и ``Class 1''. Гистограмма обычных транзакций должна быть серого
цвета, а мошеннических - красного. Горизонтальной оси дайте название
``Class''.


+*In[3]:*+
[source, ipython3]
----
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
%matplotlib inline
%config InlineBackend.figure_format = 'svg'

url = 'D:\GeekBrains\Python4DataScience\data_source\creditcard.csv'
----


+*In[120]:*+
[source, ipython3]
----
book_credit = pd.read_csv(url)
book_credit
----


+*Out[120]:*+
----
[cols=",,,,,,,,,,,,,,,,,,,,,",options="header",]
|===
| |Time |V1 |V2 |V3 |V4 |V5 |V6 |V7 |V8 |V9 |... |V21 |V22 |V23 |V24
|V25 |V26 |V27 |V28 |Amount |Class
|0 |0.0 |-1.359807 |-0.072781 |2.536347 |1.378155 |-0.338321 |0.462388
|0.239599 |0.098698 |0.363787 |... |-0.018307 |0.277838 |-0.110474
|0.066928 |0.128539 |-0.189115 |0.133558 |-0.021053 |149.62 |0

|1 |0.0 |1.191857 |0.266151 |0.166480 |0.448154 |0.060018 |-0.082361
|-0.078803 |0.085102 |-0.255425 |... |-0.225775 |-0.638672 |0.101288
|-0.339846 |0.167170 |0.125895 |-0.008983 |0.014724 |2.69 |0

|2 |1.0 |-1.358354 |-1.340163 |1.773209 |0.379780 |-0.503198 |1.800499
|0.791461 |0.247676 |-1.514654 |... |0.247998 |0.771679 |0.909412
|-0.689281 |-0.327642 |-0.139097 |-0.055353 |-0.059752 |378.66 |0

|3 |1.0 |-0.966272 |-0.185226 |1.792993 |-0.863291 |-0.010309 |1.247203
|0.237609 |0.377436 |-1.387024 |... |-0.108300 |0.005274 |-0.190321
|-1.175575 |0.647376 |-0.221929 |0.062723 |0.061458 |123.50 |0

|4 |2.0 |-1.158233 |0.877737 |1.548718 |0.403034 |-0.407193 |0.095921
|0.592941 |-0.270533 |0.817739 |... |-0.009431 |0.798278 |-0.137458
|0.141267 |-0.206010 |0.502292 |0.219422 |0.215153 |69.99 |0

|... |... |... |... |... |... |... |... |... |... |... |... |... |...
|... |... |... |... |... |... |... |...

|284802 |172786.0 |-11.881118 |10.071785 |-9.834783 |-2.066656
|-5.364473 |-2.606837 |-4.918215 |7.305334 |1.914428 |... |0.213454
|0.111864 |1.014480 |-0.509348 |1.436807 |0.250034 |0.943651 |0.823731
|0.77 |0

|284803 |172787.0 |-0.732789 |-0.055080 |2.035030 |-0.738589 |0.868229
|1.058415 |0.024330 |0.294869 |0.584800 |... |0.214205 |0.924384
|0.012463 |-1.016226 |-0.606624 |-0.395255 |0.068472 |-0.053527 |24.79
|0

|284804 |172788.0 |1.919565 |-0.301254 |-3.249640 |-0.557828 |2.630515
|3.031260 |-0.296827 |0.708417 |0.432454 |... |0.232045 |0.578229
|-0.037501 |0.640134 |0.265745 |-0.087371 |0.004455 |-0.026561 |67.88 |0

|284805 |172788.0 |-0.240440 |0.530483 |0.702510 |0.689799 |-0.377961
|0.623708 |-0.686180 |0.679145 |0.392087 |... |0.265245 |0.800049
|-0.163298 |0.123205 |-0.569159 |0.546668 |0.108821 |0.104533 |10.00 |0

|284806 |172792.0 |-0.533413 |-0.189733 |0.703337 |-0.506271 |-0.012546
|-0.649617 |1.577006 |-0.414650 |0.486180 |... |0.261057 |0.643078
|0.376777 |0.008797 |-0.473649 |-0.818267 |-0.002415 |0.013649 |217.00
|0
|===

284807 rows × 31 columns
----


+*In[ ]:*+
[source, ipython3]
----

----


+*In[ ]:*+
[source, ipython3]
----

----


+*In[124]:*+
[source, ipython3]
----
x = book_credit.iloc[:, -1].value_counts()
x
----


+*Out[124]:*+
----0    284315
1       492
Name: Class, dtype: int64----


+*In[ ]:*+
[source, ipython3]
----

----


+*In[125]:*+
[source, ipython3]
----
planets_info = pd.Series(x)
planets_info.plot(kind="bar")

plt.show()

planets_info.plot(kind="bar", logy=True)

plt.show()
----


+*Out[125]:*+
----
![svg](output_21_0.svg)

![svg](output_21_1.svg)
----

На следующем графике постройте две гистограммы по значениям признака V1
- одну для мошеннических транзакций (Class равен 1) и другую - для
обычных (Class равен 0).


+*In[127]:*+
[source, ipython3]
----
book_credit.iloc[:, 'V1'].value_counts()
----


+*Out[127]:*+
----

    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    C:\ProgramData\Anaconda3\lib\site-packages\pandas\core\indexing.py in _has_valid_tuple(self, key)
        701             try:
    --> 702                 self._validate_key(k, i)
        703             except ValueError as err:
    

    C:\ProgramData\Anaconda3\lib\site-packages\pandas\core\indexing.py in _validate_key(self, key, axis)
       1368         else:
    -> 1369             raise ValueError(f"Can only index by location with a [{self._valid_types}]")
       1370 
    

    ValueError: Can only index by location with a [integer, integer slice (START point is INCLUDED, END point is EXCLUDED), listlike of integers, boolean array]

    
    The above exception was the direct cause of the following exception:
    

    ValueError                                Traceback (most recent call last)

    <ipython-input-127-201cb2262815> in <module>
    ----> 1 book_credit.iloc[:, 'V1'].value_counts()
    

    C:\ProgramData\Anaconda3\lib\site-packages\pandas\core\indexing.py in __getitem__(self, key)
        871                     # AttributeError for IntervalTree get_value
        872                     pass
    --> 873             return self._getitem_tuple(key)
        874         else:
        875             # we by definition only have the 0th axis
    

    C:\ProgramData\Anaconda3\lib\site-packages\pandas\core\indexing.py in _getitem_tuple(self, tup)
       1441     def _getitem_tuple(self, tup: Tuple):
       1442 
    -> 1443         self._has_valid_tuple(tup)
       1444         try:
       1445             return self._getitem_lowerdim(tup)
    

    C:\ProgramData\Anaconda3\lib\site-packages\pandas\core\indexing.py in _has_valid_tuple(self, key)
        702                 self._validate_key(k, i)
        703             except ValueError as err:
    --> 704                 raise ValueError(
        705                     "Location based indexing can only have "
        706                     f"[{self._valid_types}] types"
    

    ValueError: Location based indexing can only have [integer, integer slice (START point is INCLUDED, END point is EXCLUDED), listlike of integers, boolean array] types

----


+*In[ ]:*+
[source, ipython3]
----

----


+*In[ ]:*+
[source, ipython3]
----

----


+*In[ ]:*+
[source, ipython3]
----

----
